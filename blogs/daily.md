# 日常进度及学习记录
## 5.27
今天先融会贯通了一下future， goroutine，tokio，io_uring，进程，协程这一堆

### 轻量级并发和协作式多任务
首先说future ， go的goroutine，协程，这三者在某种程度上是极度相似的
目的都在少数几个操作系统线程上高效地运行大量的并发任务，有的就一两个（

future是会把使用自己的函数改变成一个状态机，然后自己的值还没得到时状态机就进入等待状态，
future结构体变大包裹整个状态机，futures被一个特定的调度器执行，调度策略人来设定，调度对象是已经“就绪”的future，
future在等待的任务结束或者完成时会调用Waker让调度器把自己标记为“就绪”，然后等待调度。

goroutine会在需要阻塞时主动放弃自己所在的线程，然后让go的运行时调度其他goroutine来使用。

协程的原理包含上两者，其实，也可以称future为无栈协程，goroutine为有栈协程，这个栈就是程序栈，goroutine有一个很小的自己的栈，
future没有，这也就导致在goroutine里可以很好的以同步风格编码，而future差点，rust也有自己的语法糖async/await来改善编码体验，
不过像比较goroutine的异步对于程序员更加透明。future要求里面的变量生命周期不能长于自己，
否则可能导致空指针悬垂引用的问题（典中典空指针）。当然，这里不是指说future不好，future这样避免设置栈是它为了实现内存安全和高性能（
特别是避免了有栈协程的栈管理开销和潜在的栈溢出风险）所做出的设计选择。最后补充一点，就是有栈协程又称为绿色线程（green thread）

### Tokio&io_uring
io_uring是Linux提供的高效的异步I/O接口，它关键在两个队列SQ和SQE，通过批处理和共享内存这两点达到了很好的效果。
是linux系统自身的功能。批处理是指多个I/O请求可以攒一攒在一起给到内核，应用通知内核的次数减少。这里要明确，用户与内核通信本身
就有不小的开销，应尽量避免。共享内存指的是，这两个队列用户态和内核态都能看到，不需要再通过申请内存传递数据结构。

Tokio是rust异步运行时，运行时就像一个执行器，分配线程池，然后把任务扔给线程池里的工作线程执行。前面提到的future如果同时使用了tokio的话，
会被随机扔给哪个线程执行。这里补充一点，future一次执行可能执行不完，但他一旦遇到需要异步的情况就会放弃当前进程，所以会有同一个future来回进了线程池好几次的情况。

tokio和io_uring看原理很容易得知它们并不冲突，所以二者是有有机结合的可能的，Tokio_uring项目就是在做这个任务

## 5.28
### somltcp
rust原生开发的tcp服务库，以简单高效和强大的健壮性（计算机人应该用健壮性而非鲁棒性哈哈哈）为目标。所以最开始的第一版对于很多协议比如tcp的拥塞控制都没有实现。
现在的smoltcp已经十分强大,实现了多种库。对于他自身的性能以及代码质量还是得到了多方的认可的
### arceos的axnet
1.目前采用的smoktcp是一个2022年的特定版本，依赖中通过高级设置锁定了版本，所以2023年在Pull Request #907 里才添加的Reno 和 CUBIC 算法肯定是没有的。
不知道在这6份.rs源码里有设计没，这很显然是一个可以优化的点。
2.很显然crate文档也是没有的，deepwiki只是简单的生成了下，说这是隶属于网络io的，具体实现得留到明日了

## 5.29
### embassy

### axnet

### 


