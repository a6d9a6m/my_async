# 日常进度及学习记录
## 5.27
今天先融会贯通了一下future， goroutine，tokio，io_uring，进程，协程这一堆

### 轻量级并发和协作式多任务
首先说future ， go的goroutine，协程，这三者在某种程度上是极度相似的
目的都在少数几个操作系统线程上高效地运行大量的并发任务，有的就一两个（

future是会把使用自己的函数改变成一个状态机，然后自己的值还没得到时状态机就进入等待状态，
future结构体变大包裹整个状态机，futures被一个特定的调度器执行，调度策略人来设定，调度对象是已经“就绪”的future，
future在等待的任务结束或者完成时会调用Waker让调度器把自己标记为“就绪”，然后等待调度。

goroutine会在需要阻塞时主动放弃自己所在的线程，然后让go的运行时调度其他goroutine来使用。

协程的原理包含上两者，其实，也可以称future为无栈协程，goroutine为有栈协程，这个栈就是程序栈，goroutine有一个很小的自己的栈，
future没有，这也就导致在goroutine里可以很好的以同步风格编码，而future差点，rust也有自己的语法糖async/await来改善编码体验，
不过像比较goroutine的异步对于程序员更加透明。future要求里面的变量生命周期不能长于自己，
否则可能导致空指针悬垂引用的问题（典中典空指针）。当然，这里不是指说future不好，future这样避免设置栈是它为了实现内存安全和高性能（
特别是避免了有栈协程的栈管理开销和潜在的栈溢出风险）所做出的设计选择。最后补充一点，就是有栈协程又称为绿色线程（green thread）

### Tokio&io_uring
io_uring是Linux提供的高效的异步I/O接口，它关键在两个队列SQ和SQE，通过批处理和共享内存这两点达到了很好的效果。
是linux系统自身的功能。批处理是指多个I/O请求可以攒一攒在一起给到内核，应用通知内核的次数减少。这里要明确，用户与内核通信本身
就有不小的开销，应尽量避免。共享内存指的是，这两个队列用户态和内核态都能看到，不需要再通过申请内存传递数据结构。

Tokio是rust异步运行时，运行时就像一个执行器，分配线程池，然后把任务扔给线程池里的工作线程执行。前面提到的future如果同时使用了tokio的话，
会被随机扔给哪个线程执行。这里补充一点，future一次执行可能执行不完，但他一旦遇到需要异步的情况就会放弃当前进程，所以会有同一个future来回进了线程池好几次的情况。

tokio和io_uring看原理很容易得知它们并不冲突，所以二者是有有机结合的可能的，Tokio_uring项目就是在做这个任务

## 5.28
### somltcp
rust原生开发的tcp服务库，以简单高效和强大的健壮性（计算机人应该用健壮性而非鲁棒性哈哈哈）为目标。所以最开始的第一版对于很多协议比如tcp的拥塞控制都没有实现。
现在的smoltcp已经十分强大,实现了多种库。对于他自身的性能以及代码质量还是得到了多方的认可的
### arceos的axnet
1.目前采用的smoktcp是一个2022年的特定版本，依赖中通过高级设置锁定了版本，所以2023年在Pull Request #907 里才添加的Reno 和 CUBIC 算法肯定是没有的。
不知道在这6份.rs源码里有设计没，这很显然是一个可以优化的点。
2.很显然crate文档也是没有的，deepwiki只是简单的生成了下，说这是隶属于网络io的，具体实现得留到明日了

## 5.29
今天咋看了这么多语言呢？axnet没咋看。
### embassy
rust原语开发的架构，axnet应该用不到，arceos别的地方可能十分依赖它。最有意思的几点可以说说：
1. 异步执行器。异步任务当然要有个执行器，可是embassy的定位是为裸机，甚至是微处理器，就是那堆单片机提供异步。
这种情况一般运算资源特别紧张，而且没有什么操作系统支持。embassy是通过时序中断来推进执行器的。只有一个线程，这种环境哪来的第二个线程
2.  HAL表示，硬件微电子的文档那叫一个长，各家的规矩还不同，embassy使用统一的HAL表示，所以它还具有跨平台移植性。是的，基础硬件的跨平台移植性。
这里面具体的翻译任务由开发社区来完成了，目前支持的已经很多了，STM32 系列，nRF 系列，RP 系列，ESP 系列等等等等。具体的在官方的github仓库的README里面
有展示
### zig
zig是一门以高效，简洁的语言，它目前的目标是“更好的C”，啧，这语言16年才出现，一出现后就爆火，不过还是太过年轻。rust在06年就已经立项了
后面得到了Google等业界的支持，现在才算比较流行。zig没有什么实际应用案例，也缺乏支持的企业，只能说任重道远，按照语言的发展规律，可能我到中年时它才能名扬天下吧。

zig里说是解决了函数染色的问题。以rust做对比。如果我们要让一个函数能够异步运行，我们需要添加async标记，编译器会对函数进行宏展开。
严谨的说，就是，“实现async的函数内的每两个await()点之间都会生成future”。zig是在代码编写时用suspend标记代码块，这个标记异味这这一部分代码无法立刻完成，
可能需要等待。然后这段代码被zig里标记async的函数执行时，会进行异步操作。大致过程与future差不多，名词不一样。什么帧挂起，从函数视角看就是非阻塞运行，
并且这个值在实际求出前一直是一个没有意义的值。如果执行函数没有async标记，代码到suspend这就会阻塞等待求值。

函数染色是说因为异步函数形式与同步不一样，一个调用了异步函数的函数自己大概率也得异步，否则就显式阻塞等待。zig这里同步异步的函数是同一个类型，
所以说是灭了这个问题。不过呀，这个没什么用，因为就是一个名字的问题。rust同步异步两套代码zig也免不了。

zig最著称的是编译时运行，就是在可以把代码在生成可执行二进制文件之前先运行求值，显然一般这都是不依赖外部输入的运算，比如，算质数，当然这肯定不能搞无限循环，
不过意思已经明显表达出来了。这个能大大减少二进制程序的运行耗时，就像做饭前有人先把食材处理好了一样，最后执行很自然会飞快。

运行是快了，编译可就慢了，不过由于没有外部依赖，可以进行整合优化。大抵就这样

zig是想成为“更好的C”，那它肯定避免不了C的理念，“信任程序员”。这要求编写的人需要对于语言有深刻的掌握，对变量的分配有深刻的体会，
否则程序的正确性，健壮性很难保证。于此相比，rust只要能编译通过，这个代码基本就可以进生产环境，直接采用。从这个角度看，rust更容易被工业界接受，大项目使用也更
容易。zig只能说未来可期吧（，看未来对极致性能的追求有多高

## 5.30
赞叹！高山仰止！不得不说郑友捷大神实在是太有实力了。今天分析axnet，一个系统，只有在你想要提升它的性能时，你才能发现设计者当年的权衡取舍，设计者的苦心孤诣。
### axnet
axnet ，arceos的网络模块，虽然直接用deepwiki生成的文档提了几处改进建议，但它引用的源文件并不全面，于是我进行了更加详尽源码分析。
#### tcp.rs
tcp模块，最长的一个文件，也是实现的最完善的一个文件，里面有一个复杂又十分经典的tcp状态机。这个状态机的状态转换做到了原子操作级。整个tcp的实现是unsafe sync
也就是说并没有用很多rust的检查，是像C那样直接指针操作。具体状态转换图可以看deepwiki上生成的。有STATE_CLOSED、
STATE_BUSY、STATE_CONNECTING、STATE_CONNECTED、STATE_LISTENING这几个状态，有客户端服务端的api，本身没什么问题。
#### udp.rs
udp协议实现，由于udp是无状态的，所以不需要状态机，所以这里的代码就看着简单的很多。唯一可能需要注意的是get_ephemeral_port跟tcp里面的相比实在太简单了
现在是完全依赖smoltcp底层库的检测，所以可能需要仿照tcp里面的升级一下
#### listen_table.rs
这个里面的accept在syn_queue中查找已连接套接字是一个遍历，这个可以纯粹的从算法角度进行优化，目前对于时空整体考虑明显还很欠缺，对于空间申请下面其他文件
也能看出，对泛洪攻击、高频查找十分缺乏抵抗力

snoop_tcp_packet，这个每个都创立新的结构体，遇见SYN泛洪就要寄，可以延迟分配整个结构，使用syn cooki之类的先分配

DeviceWrapper 内部使用 RefCell<AxNetDevice>。注释里说明“use RefCell is enough since it's wrapped in Mutex in InterfaceWrapper”。
外部 Mutex 保证了对 DeviceWrapper 的独占访问，因此内部的 RefCell 不会遇到并发借用问题。RefCell 在这里主要用于在 smoltcp 的 Device trait 
方法（它们通常接收 &mut self）和 AxNetDevice 的API（可能接收 &self 但需要内部可变性，或者反之）之间进行适配。像这样的考虑还有很多，在这里真的佩服
大神。有些我自己也看不懂，还问了问ai，它也赞叹设计的严谨，改进需要考虑实际场景。

#### dns.rs
query 这里没有完全异步，如异，这里可以返回future。还有就是DnsSocket的分配，这个早期考虑不到是正常的

#### addr.rs
问题最大，最明显的文件。显然受到22年时smoltcp的版本限制，所以首先，不支持IPV6，还有，有一个不恰当的，多出的unsafe实现。顺手改了

#### 小结
目前分析完不知道项目跑的通不（还没试着跑，歪比巴卜），还有就是网络的专属测试得找找，或许是那个httpsever应用。最后就是CI/CD里对这个覆盖的怎么样。
目前我对axnet的分析大致就是这样了

## 5.31
### ipc
### vbso