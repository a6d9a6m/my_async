# 日常进度及学习记录
## 5.27
今天先融会贯通了一下future， goruntime，tokio，io_uring，进程，协程这一堆

### 轻量级并发和协作式多任务
首先说future ， go的goruntime，协程，这三者在某种程度上是极度相似的
目的都是减少切换线程上下文保存的开销，直接不开新线程（

future是会把使用自己的函数改变成一个状态机，然后自己的值还没得到时状态机就进入等待状态，
future结构体变大包裹整个状态机，futures被一个特定的调度器执行，调度策略人来设定，调度对象是已经“就绪”的future，
future在等待的任务结束或者完成时会调用Waker让调度器把自己标记为“就绪”，然后等待调度。

goruntime会在需要阻塞时主动放弃自己所在的线程，然后让go的运行时调度其他goruntime来使用。

协程的原理包含上两者，其实，也可以称future为无栈协程，goruntime为有栈协程，这个栈就是程序栈，goruntime有一个很小的自己的栈，
future没有，这也就导致在goruntime里可以很好的以同步风格编码，而future不能，future要求里面的变量生命周期不能长于自己，
否则可能导致空指针悬垂引用的问题（典中典空指针）。当然，这里不是指说future不好，future这样避免设置栈是它为了实现内存安全和高性能（
特别是避免了有栈协程的栈管理开销和潜在的栈溢出风险）所做出的设计选择

### Tokio&io_uring
io_uring是Linux提供的高效的异步I/O接口，它关键在两个队列SQ和SQE，通过批处理和共享内存这两点达到了很好的效果。
是linux系统自身的功能。批处理是指多个I/O请求可以攒一攒在一起给到内核，应用通知内核的次数减少。这里要明确，用户与内核通信本身
就有不小的开销，应尽量避免。共享内存指的是，这两个队列用户态和内核态都能看到，不需要再通过申请内存传递数据结构。

Tokio是rust异步运行时，运行时就像一个执行器，分配线程池，然后把任务扔给线程池里的工作线程执行。前面提到的future如果同时使用了tokio的话，
会被随机扔给哪个线程执行。这里补充一点，future一次执行可能执行不完，但他一旦遇到需要异步的情况就会放弃当前进程，所以会有同一个future来回进了线程池好几次的情况。

tokio和io_uring看原理很容易得知它们并不冲突，所以二者是有有机结合的可能的，Tokio_uring项目就是在做这个任务

### embassy和smoltcp

