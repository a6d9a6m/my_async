# 一份极简 Rust 异步运行时的设计与实现文档
## 1. 引言：我们为何要构建一个运行时？
在 Rust 中，当我们写下 async fn 和 .await 时，我们只是在描述一个可以被暂停和恢复的计算流程。这些 Future 本身是惰性的——它们在被主动驱动（轮询）之前什么也不会做。

这个项目 my-runtime 的核心目标，就是亲手构建一个最基础的驱动引擎，也可以称之为异步运行时 (Async Runtime)。通过构建它，我们可以揭开 async/await 语法糖背后的神秘面纱，深刻理解异步代码是如何被并发执行的。

虽然我们的实现远不及 tokio 强大，但它就像一个“玩具模型”，麻雀虽小，五脏俱全。它包含了 tokio 这类工业级运行时最核心、最基础的设计思想。

## 2. 核心设计思想
运行时构建于以下几个关键思想之上：

### 思想一：Future 是惰性的，执行器 (Executor) 赋予其生命
这是 Rust 异步生态的基石。一个 Future 在被 .await 时，实际上是将其交给了执行器。执行器的工作就是不断地调用 Future 的 poll 方法。

#### 实现体现：
定义了 Executor 结构体，其核心是一个 run 方法内的循环。
这个循环不断从任务队列 (ready_queue) 中取出 Task。
取出后，它会调用 task.poll()。

结论：没有 Executor 的 poll，任何 async 代码块都只是一段不会被执行的数据结构。
### 思想二：分离 “任务定义” 与 “任务执行”
为了实现并发，我们必须能够“定义”很多任务，然后将它们交给一个独立的“执行”组件去处理。

#### 实现体现：
任务定义：用户通过调用 async 代码块来定义一个 Future。

任务派发：设计了 Spawner 组件。它的唯一职责就是接收一个 Future，将其包装成一个可执行的 Task，然后扔进一个所有任务共享的“待办事项”列表里（即这里的 mpsc::channel）。spawner.spawn(...) 就是这个动作的入口。

任务执行：Executor 在另一端，完全不知道任务是怎么来的，它只负责从“待办事项”列表里取出任务并执行。

结论：Spawner 和 Executor 通过一个通道 (channel) 解耦，完美地实现了“定义”与“执行”的分离。这使得我们可以在程序的任何地方（只要有 Spawner 的克隆）创建任务，而无需关心它们具体在何时何地被执行。
### 思想三：事件驱动与协作式调度 (Event-Driven & Cooperative Scheduling)
这是异步运行时区别于传统多线程的关键，也是 Waker 机制的核心价值所在。

#### 协作式调度：

调度是协作式的。一个任务如果不主动放弃 CPU，它就会一直执行下去。当一个 Future 在 poll 时发现自己所等待的资源（比如一个定时器）还未就绪，它会返回 Poll::Pending。

实现体现：在 Executor 的 run 循环中，如果 poll 返回 Pending，我们不会卡住或重试，而是直接丢弃当前任务的引用，继续处理队列中的下一个任务。
#### 事件驱动：
任务在返回 Pending 之前，会从 Context 中把 Waker 保存下来（例如这里的 TimerFuture 所做的那样）。
当外部事件（定时器到期、网络数据到达等）发生时，该事件的监听者会调用 waker.wake()。
wake() 方法会触发一个动作——将对应的 Task 重新放回 Executor 的 ready_queue 中。
#### 实现体现：
我们通过 ArcWake trait 为 Task 实现了 wake_by_ref 方法。该方法的核心逻辑就是 task_sender.send(self)，即将自身重新调度。

结论：Poll::Pending + Waker 共同构成了一个高效的事件驱动循环。任务仅在真正有事可做时才会被执行，CPU 时间不会被浪费在无意义的等待上。
## 3. 组件解析与 Tokio 对照

| my_runtime       | 设计思想                                                 | tokio 中的对应概念                                  | 异同点与 tokio 的先进之处                                                                                                                                  |
|------------------|------------------------------------------------------|-------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Task             | 	一个可被调度的异步计算单元。我们用 Arc<Mutex<Future>> 包装。            | tokio::task                               |都是可执行单元。Tokio 更强：Tokio 的 Task 与其复杂的调度器和生命周期管理（如 JoinHandle 用于获取结果和取消任务）深度集成。                 |
| Spawner          | 	任务注入器。通过一个 mpsc::Sender 将任务发送给执行器。                  | 	tokio::spawn()                           |都是向运行时提交任务的入口。Tokio 更强：tokio::spawn 将任务提交给一个高度优化的、支持多线程的调度器队列，而非简单的 MPSC Channel。            |
| Executor         | 	单线程循环。从一个队列中取任务并 poll。                              | 	tokio::runtime::Runtime	                  |有差异，这里的只是最简单的调度器。Tokio 更强：Tokio 运行时包含一个多线程工作窃取 (Work-Stealing) 调度器。当一个线程的本地任务队列为空时，它会去“窃取”其他线程的任务来执行，极大地提高了多核 CPU 的利用率。这里的 Executor 只是一个单线程的 while 循环。 |
| Waker/ArcWake    | 	任务的唤醒机制。wake() 会通过 channel 将任务重新调度。                 | 	Tokio 内部的 Waker 实现	                   | 都是任务向调度器注册的回调。Tokio 更强：Tokio 的 Waker 与其 I/O 驱动（Reactor）紧密相连。当一个网络事件就绪时，Reactor 会唤醒对应的 Waker，后者再通知调度器，整个过程极其高效。                                      |
| TimerFuture (模拟) | 	模拟一个会等待外部事件的 Future。用 thread::spawn + sleep 来实现。    | 	Tokio 的 I/O 驱动 (Reactor) 和定时器          | 有差异，这里的模拟非常粗糙。Tokio 更强：Tokio 有一个专门的 Reactor 组件，它基于操作系统的 epoll/kqueue/IOCP 等机制，可以用单个线程高效地监听成千上万个 I/O 事件（网络、文件）和定时器。这避免了为每个等待操作都创建一个系统线程的巨大开销，是 Tokio 高性能的核心。| 


## 4. 项目的局限性与学习路径
   由于时间仓促，这个简单的异步运行时有很多局限

#### 单线程：无法利用多核 CPU 的优势。
伪 I/O：使用 thread::spawn 来模拟异步等待，在真实 I/O 场景下会迅速耗尽系统资源。

调度器简单：简单的先进先出队列，可能导致任务饥饿或效率低下。
#### 下一步学习路径：

探索 mio：mio (Metal I/O) 是 tokio 用来构建其 Reactor 的底层库。充分利用了各个系统的特化的高效I事件队列 epoll/kqueue/IOCP

理解工作窃取调度：跨线程的任务调度。

使用 tokio 的高级功能：在实践中运用 tokio::select!, tokio::sync (异步锁、信号量), JoinHandle 等，感受一个成熟运行时提供的强大能力。
## 5. 总结
构建 my_runtime完，可以很容易意识到，一个异步运行时本质上就是一个围绕 poll 和 wake 构建的一个循环。waker负责放任务，poll负责驱动
